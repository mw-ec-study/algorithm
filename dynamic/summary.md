**”중복되는 연산을 줄이자”**

컴퓨터를 활용해 해결해야 하는 문제들 중 연산하는 시간이 매우 오래 걸리거나 메모리 공간이 매우 많이 필요한 문제들이 있다. 그래서 울이는 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.

대표적으로 **다이나믹 프로그래밍** 기법이 있다.

다이나믹 프로그래밍의 방식 중 탑다운, 보텁업에 이용되는 메모이제이션 기법을 알아보자.

다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 피보나치 수열이 있다. 피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.

이 피보나치 수열을 점화식으로 표현하면 다음과 같다.

$a_n = a_{n-1} + a_{n-2}, a_1 = 1, a_2 = 1$수

수학적 점화식을 프로그래밍으로 표현하려면 재귀 함수를 사용하면 간단하다.

```python
def fibo(x):
		if x == 1 or x == 2:
				return 1
		return fibo(x-1) + fibo(x-2)
```

하지만 피보나치 수열의 소스코드를 이렇게 작성하면 문제가 발생한다.
`fibo(n)` 함수에 n 값이 커질수록 시간이 기하급수적으로 늘어나기 때문이다.  $O(2^n)$의 지수 시간이 소요된다. (n이 30이면, 약 10억 가량 연산)
`fibo(6)` 일 때의 호출과정을 그림으로 그리면 다음과 같다.

![fibo(6).png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ac2916ad-77fe-4e9f-8b13-6619f455ae59/fibo(6).png)

그림을 보면 동일한 함수가 반복적으로 호출되는 것을 알 수 있다. 이미 한 번 계산했지만, 계속 호출할 때마다 계산하는 것이다.  이러한 문제는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다. 물론 항상 사용할 수 없고 다음 조건을 만족하면 사용가능 하다.

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 성능 문제는 **메모이제이션 기법**(캐싱)으로 해결할 수 있다.

```python
d = [0] * 100 #작은 문제 결과값 저장

def fibo(x):
		if x == 1 or x == 2:
				return 1
		if d[x] != 0:
				return d[x]
		d[x] = fibo(x-1) + fibo(x-2)
		
		return d[x]

print(fibo(99))
```

프로그램을 실행시켜보면 99를 넣었음에도 금방 정답을 도출했다.

정리하면 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 한번 해결한 문제는 다시 해결하지 않고 한 번씩만 풀어 큰 문제를 효율적으로 해결한다.

![fibo(6)_dynamic.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/635e9a43-63b4-4903-bb97-f14761823381/fibo(6)_dynamic.png)

## 다이나믹 알고리즘 테스트 문제 해결법

1. 주어진 n을 작은 문제인 i로 생각한다.
2. 초기값을 설정한다.
3. 점화식을 세워서 코드로 적용시킨다.

## 1. 1로 만들기

정수 n이 주어질 때 다음 4가지의 연산으로 1로 만드는 최소 횟수를 구해라

1. n에서 1을 뺀다.
2. 5로 나눈다.
3. 3으로 나눈다.
4. 2로 나눈다.

### 소스 코드

```python
n = int(input()) #n 입력

dy = [0] * (n+1) #캐시 테이블

for i in range(2, n+1):
    dy[i] = dy[i-1] + 1
    if i % 2 == 0:
        dy[i] = min(dy[i//2]+1, dy[i])
    if i % 3 == 0:
        dy[i] = min(dy[i//3]+1, dy[i])
    if i % 5 == 0:
        dy[i] = min(dy[i//5]+1, dy[i])
        
print(dp[n])
```

### 아이디어

바텀업 방식으로 2부터 작은 문제를 해결한다. 

2는 2로 나누어서 한 번에 계산이 되고 그 다음 수인 3도 한번에 계산이 된다. 

4의 경우 두 가지로 볼 수 있다.

1. $(4-1)/3$
2. $4/2/2$

먼저 작은 문제를 생각해 보면 3에 1을 더하면 4가 되므로 반대로 `3을 1로 만드는 횟수`에 +1을 해주면 `4가 1이 되는 횟수`와 동일할 것이고, 2에 2를 곱하면 4가 되므로 `2에서 1로 만드는 횟수`에 연산 횟수 +1을 해주면 같은 횟수가 될 것이다. 

이를 n까지 계산하면 큰 문제가 해결되는 것이다.

## 2. 바닥 공사

$(1 * 2)$, $(2*1)$, $(2*2)$ 타일 세개를 이용하여 $(2*n)$ 타일을 가득 채우는 경우의 수를 구하라.

### 소스코드

```python
n = int(input())

dy = [0] * 100
dy[1] = 1
dy[2] = 3

for i in range(n):
    dy[i] = (dy[i-1] + dy[i-2] * 2) % 796796
```

### 아이디어

- 작은 문제(초기값)
    
    n = 1 일 때, $(2*1)$타일을 채우는 경우의 수는 1이다.
    
    n = 2 일 때, $(2 * 2)$타일을 채우는 경우의 수는 2이다.
    
    이 때, 끝을 $(1*2)*2$ 타일, $(2*2)$ 타일로 마무리하는 경우와 $(2*1)$로 마무리하는 경우로 나뉜다.
    
    그렇다면 n = 3 일 때, $(2*3)$타일을 채우는 경우의 수는 
    
    n = 1 일 때 타일에 $(1*2) *2$, $(2*2)$ 타일 두 가지를 붙일 경우와
    
    n = 2 일 때, $(2*1)$타일을 붙이는 경우를 더하면 n = 3을 구할 수 있다.
    
- 점화식
    
    $n_i = n_{i-1} + 2(n_{i-2})$
    

## 3. 개미 전사

배열이 있을 때 배열의 요소 중 인접한 숫자를 더하지 않고 더할 수 있는 최대값을 구하라

[1, 3, 1, 5] → 8

### 소스코드

```python
n = int(input())
array = list(map(int, input().split()))

dy = [0] * 100

dy[0] = array[0]
dy[1] = max(array[0], array[1])

for i in range(2, n):
    dy[i] = max(dy[i-1], dy[i-2] + array[i])

print(dy[n-1])
```

### 아이디어

- 작은 문제(초기값)
    
    dy[0] = array[0] 
    
    dy[1] = max(array[0], array[1]) 인덱스 0과 1 중 큰 값을 둔다.
    
    i = 2 일 때, dy[1] 와 dy[0] + array[2] 중 더 큰 값을 dy[2]에 기록한다.
    
    i = 3 일 때, dy[2] 와 dy[1] + dy[3] 중 더 큰 값을 dy[3]에 기록한다.
    
- 점화식
    
    $n_i = max(n_{i-1}, n_{n_i-2} + k_i)$